<script>
    import { afterUpdate, onMount, createEventDispatcher } from 'svelte';

    import { activeFilters, searchQuery, settings } from '../stores';
    import FilterPill from './FilterPill.svelte';
    import FilterScrollButton from './FilterScrollButton.svelte';
    import { Checkbox } from 'figma-plugin-ds-svelte';

    export { className as class };
    let className = '';

    let filterListArrayNodeTypeArray = [];
    export { filterListArrayNodeTypeArray as filterListNodeTypeList };

    // Example optionlist formatting
    // export let optionList = [
    //     { value: 'item1', label: 'Passthrough', group: 'group1', selected: true },
    //     { value: 'item2', label: 'Normal ', group: 'group1', selected: false },
    //     { value: 'item3', label: 'Darken', group: 'group2', selected: false },
    //     { value: 'item4', label: 'Multiply', group: 'group2', selected: false },
    //     { value: 'item4', label: 'Color Burn', group: 'group2', selected: false },
    // ];

    $: console.log($activeFilters);

    let filterArray = [];

    filterArray = sortAndBuildNodeTypeFilter(filterListArrayNodeTypeArray);

    // Current filterListArrayNodeTypeArray
    //     0: {node_type: 'ALL', name: 'All Types', count: 0, sticky: true, default: true, …}
    // 1: {node_type: 'COMPONENT', name: 'Component', count: 1, sticky: false, checked: false, …}
    // 2: {node_type: 'BOOLEAN_OPERATION', name: 'Boolean Operation', count: 0, sticky: false, checked: false, …}
    // 3: {node_type: 'COMPONENT_SET', name: 'Component Set', count: 0, sticky: false, checked: false, …}
    // 4: {node_type: 'ELLIPSE', name: 'Ellipse', count: 0, sticky: false, checked: false, …}
    // 5: {node_type: 'FRAME', name: 'Frame', count: 0, sticky: false, checked: false, …}
    // 6: {node_type: 'GROUP', name: 'Group', count: 0, sticky: false, checked: false, …}
    // 7: {node_type: 'INSTANCE', name: 'Instance', count: 0, sticky: false, checked: false, …}
    // 8: {node_type: 'LINE', name: 'Line', count: 0, sticky: false, checked: false, …}
    // 9: {node_type: 'POLYGON', name: 'Polygon', count: 0, sticky: false, checked: false, …}
    // 10: {node_type: 'RECTANGLE', name: 'Rectangle', count: 0, sticky: false, checked: false, …}
    // 11: {node_type: 'SLICE', name: 'Slice', count: 0, sticky: false, checked: false, …}
    // 12: {node_type: 'STAR', name: 'Star', count: 0, sticky: false, checked: false, …}
    // 13: {node_type: 'TEXT', name: 'Text', count: 0, sticky: false, checked: false, …}
    // 14: {node_type: 'VECTOR', name: 'Vector', count: 0, sticky: false, checked: false, …}

    function sortAndBuildNodeTypeFilter(array) {
        let _filterArray;
        array.forEach((el) => {
            const filterType = el.filterType;
            const filters = el.filterOptions;

            let stickyTypes = filters.filter((elem) => elem.sticky == true);
            let regularTypes = filters.filter(
                (elem) => elem.sticky === false || elem.sticky === undefined
            );

            // Sort by filter counts if rememberNodeFilterCounts is on
            if (
                $settings.rememberNodeFilterCounts &&
                filterType === 'node_type'
            ) {
                stickyTypes.sort((a, b) => {
                    return b.count - a.count;
                });
                regularTypes.sort((a, b) => {
                    return b.count - a.count;
                });
            }

            let _filterOptions = stickyTypes.concat(regularTypes);

            _filterOptions.forEach((element) => {
                const enabled = element?.default ? true : false;
                element.selected = enabled;
                element.label = element.name;

                if (element.sticky == true) {
                    element.group = 'group1';
                } else {
                    element.group = 'group2';
                }
            });

            el.filterOptions = _filterOptions;
        });

        return array;
    }

    let _activeFilters = [];

    // array with checked filters excluding ALL
    let checkedLayerFilters;

    const dispatch = createEventDispatcher();

    function handleFilter(event) {
        //detail: [NODE_TYPE, checked]

        // console.log('Filter section event');
        // console.log(event);

        // if (event.detail[0] == 'ALL') {
        //     console.log('reset all');
        //     filterListArrayNodeTypeArray.forEach((elem) => {
        //         elem.checked = false;
        //     });
        // }

        // checkedLayerFilters = 0;

        // checkedLayerFilters = filterListArrayNodeTypeArray.filter(
        //     (elem) => elem.checked == true && elem.node_type != 'ALL'
        // );

        // console.log(checkedLayerFilters);
        // let ALL_FILTER_I = filterListArrayNodeTypeArray.findIndex(
        //     (elem) => elem.node_type == 'ALL'
        // );
        // if (checkedLayerFilters.length > 0) {
        //     filterListArrayNodeTypeArray[ALL_FILTER_I].checked = false;

        //     dispatch('filterChanged', true);
        // } else {
        //     filterListArrayNodeTypeArray[ALL_FILTER_I].checked = true;
        //     dispatch('filterChanged', false);
        // }

        // const _activeFilterObj = filterListArrayNodeTypeArray.filter(
        //     (elem) => elem.checked == true
        // );

        // let _activeFilters = [];
        // _activeFilterObj.forEach((element) => {
        //     _activeFilters.push(element.node_type);
        // });

        const filterType = event.detail.filterType;

        const selection = [];
        event.detail.selection.forEach((elem) => {
            selection.push(elem.value);
        });

        $activeFilters[filterType] = selection;

        initScrollPosition();
    }

    let filterDefinitionsElem;
    let scrollMinMax = [];

    onMount(() => {
        // console.log(filterDefinitionsElem);
        initScrollPosition();
    });

    // TODO: 20.07. fix being able to scroll even when the filter is smaller than the plugin window
    function initScrollPosition() {
        scrollMinMax = [
            0,
            -1 *
                (filterDefinitionsElem.scrollWidth -
                    filterDefinitionsElem.parentElement.clientWidth) -
                8,
        ];

        //TODO: fix figma not correctly assigning scrolllWidth
        // scrollWidth: 1051
        //         1007
        // VM111974:2852 320
        // VM111974:2853 (2) [0, -695]

        // console.log(filterDefinitionsElem.scrollWidth);
        // console.log(filterDefinitionsElem.parentElement.clientWidth);
        // console.log(scrollMinMax);
    }

    let scrollPos = 0;

    afterUpdate(() => {});

    function handleScroll(event) {
        // TODO: there has to be a better way than recalculating the scroll bounds on every scroll
        initScrollPosition();
        moveFilterList(event.deltaY);
    }

    function moveFilterList(delta) {
        // multiply by -1 to reverse scroll direction (to make it conform to standard mouse wheel behavior)
        let targetPos = (scrollPos += delta * -1);

        // scrollMinMax[0] is 0
        if (targetPos >= scrollMinMax[0]) {
            targetPos = Math.min(0, targetPos);
        }

        //scrollMinMax[1] is the negative width of the scroll wrapper
        if (targetPos <= scrollMinMax[1]) {
            // +8 is a hack to simulate a padding right of 8 pixels for the filter list
            targetPos = Math.max(scrollMinMax[1], targetPos);
        }

        scrollPos = targetPos;

        // console.log(scrollPos, scrollMinMax);
    }

    function handleManualScroll(value) {
        moveFilterList(value);
    }

    let _searchQuery = $searchQuery;

    $: _searchQuery.node_types = _activeFilters;
</script>

<svelte:window on:resize={initScrollPosition} />
<div class="filter-wrapper">
    <div class="scroll-wrapper {className}">
        <!-- {#if scrollPos != scrollMinMax[0]}
        <FilterScrollButton
            on:scrollButton={() => handleManualScroll(-180)}
            left
            class="button--left">←</FilterScrollButton
        >
    {/if} -->

        <div
            id="filterDefinitions"
            bind:this={filterDefinitionsElem}
            class="filter-pill-group flex pl-xxsmall"
            on:wheel|preventDefault|stopPropagation={handleScroll}
            style="left: {scrollPos}px;"
            tabindex="0"
        >
            {#each filterArray as filter}
                <FilterPill
                    on:selectFilter={handleFilter}
                    optionList={filter.filterOptions}
                    filterData={filter.filterData}
                />
            {/each}
        </div>
        <!-- {#if scrollPos != scrollMinMax[1]}
        <FilterScrollButton
            on:scrollButton={() => handleManualScroll(180)}
            right
            class="button--right">→</FilterScrollButton
        >
    {/if} -->
    </div>
</div>

<style>
    .filter-pill-group {
        gap: 8px;
        /* overflow-x: hidden; */
        position: absolute;
        transition: left 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    .scroll-wrapper {
        position: relative;
        overflow-x: clip;
        height: 28px;
    }
</style>
